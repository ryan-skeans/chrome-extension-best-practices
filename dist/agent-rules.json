[
  {
    "id": "permissions.no-all-urls",
    "domain": "chrome-extension",
    "version": 1,
    "category": "permissions",
    "impact": "high",
    "confidence": 1,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "<all_urls>"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "permissions",
        "host_permissions"
      ]
    },
    "summary": "Avoid requesting <all_urls> permission",
    "rationale": "Requesting access to all URLs triggers a separate, more rigorous review process and alarms users during installation. It violates the principle of least privilege.",
    "recommendation": {
      "action": "Limit host permissions to specific domains",
      "before": "\"host_permissions\": [\"<all_urls>\"]",
      "after": "\"host_permissions\": [\"https://*.example.com/*\"]"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/mv3/permission_warnings/"
    ]
  },
  {
    "id": "permissions.minimize-host-permissions",
    "domain": "chrome-extension",
    "version": 1,
    "category": "permissions",
    "impact": "high",
    "confidence": 0.9,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "*://*/*",
        "http://*/*",
        "https://*/*"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "host_permissions"
      ]
    },
    "summary": "Avoid wildcard host permissions",
    "rationale": "Broad wildcard permissions (*://*/*) grant access to every site, presenting a high security risk and reducing user trust.",
    "recommendation": {
      "action": "Specify exact domains required for functionality",
      "before": "\"host_permissions\": [\"*://*/*\"]",
      "after": "\"host_permissions\": [\"https://api.myservice.com/*\"]"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/mv3/declare_permissions/"
    ]
  },
  {
    "id": "permissions.active-tab",
    "domain": "chrome-extension",
    "version": 1,
    "category": "permissions",
    "impact": "medium",
    "confidence": 0.8,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "tabs"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "permissions"
      ]
    },
    "summary": "Prefer activeTab over broad tabs or host permissions",
    "rationale": "The activeTab permission grants temporary access to the current tab only when the user invokes the extension (via click, keyboard shortcut, or context menu). This avoids permanent host permissions and reduces user friction. Note: 'tabs' permission is still needed if you require tab.url/title without a user gesture.",
    "recommendation": {
      "action": "Replace 'tabs' or host permissions with 'activeTab' where interactive access is sufficient",
      "before": "\"permissions\": [\"tabs\"]",
      "after": "\"permissions\": [\"activeTab\"]"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/reference/api/tabs#manifest"
    ]
  },
  {
    "id": "permissions.clipboard-access",
    "domain": "chrome-extension",
    "version": 1,
    "category": "permissions",
    "impact": "medium",
    "confidence": 1,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "clipboardRead",
        "clipboardWrite"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "permissions"
      ]
    },
    "summary": "Use clipboard permissions only when necessary",
    "rationale": "Clipboard access is sensitive. Ensure it is absolutely required for the core feature set.",
    "recommendation": {
      "action": "Remove clipboard permissions if not critical, or use the standard Clipboard API with user gesture",
      "before": "\"permissions\": [\"clipboardRead\"]",
      "after": "// Use navigator.clipboard.readText() inside a user-triggered event handler"
    }
  },
  {
    "id": "permissions.optional-permissions",
    "domain": "chrome-extension",
    "version": 1,
    "category": "permissions",
    "impact": "medium",
    "confidence": 0.8,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "permissions"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "permissions",
        "optional_permissions"
      ]
    },
    "summary": "Use optional_permissions for non-critical features",
    "rationale": "Optional permissions are requested at runtime when the user needs the feature, rather than at install time. This reduces friction during installation and follows the principle of least privilege. Users are more likely to install extensions that request fewer upfront permissions.",
    "recommendation": {
      "action": "Move non-essential permissions to optional_permissions",
      "before": "\"permissions\": [\"storage\", \"tabs\", \"downloads\", \"bookmarks\"]",
      "after": "\"permissions\": [\"storage\"],\n\"optional_permissions\": [\"tabs\", \"downloads\", \"bookmarks\"]"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/reference/api/permissions"
    ]
  },
  {
    "id": "security.no-remote-code",
    "domain": "chrome-extension",
    "version": 1,
    "category": "security",
    "impact": "high",
    "confidence": 1,
    "appliesTo": [
      "manifest",
      "content-script",
      "service-worker"
    ],
    "detection": {
      "signals": [
        "eval",
        "new Function",
        "generated-script"
      ],
      "filePatterns": [
        "**/*.js",
        "**/*.ts",
        "manifest.json"
      ],
      "manifestKeys": [
        "content_security_policy"
      ]
    },
    "summary": "Remote code execution is prohibited",
    "rationale": "Manifest V3 strictly forbids remotely hosted code (including via eval or handling scripts from external servers).",
    "recommendation": {
      "action": "Bundle all necessary libraries inside the extension package",
      "before": "script.src = 'https://cdn.example.com/lib.js';",
      "after": "import { lib } from './local-lib.js';"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/mv3/intro/mv3-migration/#remotely-hosted-code"
    ]
  },
  {
    "id": "security.strict-csp",
    "domain": "chrome-extension",
    "version": 1,
    "category": "security",
    "impact": "high",
    "confidence": 1,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "unsafe-eval",
        "unsafe-inline",
        "https:",
        "http:"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "content_security_policy"
      ]
    },
    "summary": "Enforce strict Content Security Policy (CSP)",
    "rationale": "Manifest V3 requires 'script-src' and 'object-src' to be 'self' or 'none'. 'unsafe-eval' is only permitted in sandboxed pages, and remote sources are banned.",
    "recommendation": {
      "action": "Remove remote domains and unsafe policies from CSP",
      "before": "\"content_security_policy\": { \"extension_pages\": \"script-src 'self' https://example.com; object-src 'self'\" }",
      "after": "\"content_security_policy\": { \"extension_pages\": \"script-src 'self'; object-src 'self'\" }"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/mv3/manifest/content_security_policy/"
    ]
  },
  {
    "id": "security.content-script-isolation",
    "domain": "chrome-extension",
    "version": 1,
    "category": "security",
    "impact": "high",
    "confidence": 0.9,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "\"world\": \"MAIN\""
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "content_scripts"
      ]
    },
    "summary": "Avoid running content scripts in the MAIN world",
    "rationale": "Scripts in the MAIN world share the host page's execution environment, allowing the page to interfere with them or steal data. Use the default ISOLATED world for security.",
    "recommendation": {
      "action": "Remove 'world': 'MAIN' or switch to 'ISOLATED'",
      "before": "\"content_scripts\": [{ \"world\": \"MAIN\", ... }]",
      "after": "\"content_scripts\": [{ \"world\": \"ISOLATED\", ... }]"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/mv3/content_scripts/#isolated_world"
    ]
  },
  {
    "id": "security.safe-message-passing",
    "domain": "chrome-extension",
    "version": 1,
    "category": "security",
    "impact": "high",
    "confidence": 0.8,
    "appliesTo": [
      "service-worker",
      "content-script"
    ],
    "detection": {
      "signals": [
        "runtime.onMessage.addListener",
        "sender.tab",
        "sender.id"
      ],
      "filePatterns": [
        "**/*.js",
        "**/*.ts"
      ],
      "manifestKeys": []
    },
    "summary": "Validate sender in all message listeners",
    "rationale": "Message listeners can receive messages from other extensions or websites if 'externally_connectable' is defined. Even without it, validating 'sender.id' ensures you are only processing trusted checks.",
    "recommendation": {
      "action": "Check sender.id equals chrome.runtime.id in listeners",
      "before": "chrome.runtime.onMessage.addListener((msg) => { doWork(msg); });",
      "after": "chrome.runtime.onMessage.addListener((msg, sender) => { if (sender.id !== chrome.runtime.id) return; doWork(msg); });"
    }
  },
  {
    "id": "security.https-only",
    "domain": "chrome-extension",
    "version": 1,
    "category": "security",
    "impact": "high",
    "confidence": 1,
    "appliesTo": [
      "service-worker",
      "content-script"
    ],
    "detection": {
      "signals": [
        "http://"
      ],
      "filePatterns": [
        "**/*.js",
        "**/*.ts"
      ],
      "manifestKeys": []
    },
    "summary": "Use HTTPS for all network requests",
    "rationale": "Unencrypted HTTP requests are vulnerable to MITM attacks. Chrome extensions should only communicate over secure channels.",
    "recommendation": {
      "action": "Change all API endpoints to https://",
      "before": "fetch('http://api.example.com/data')",
      "after": "fetch('https://api.example.com/data')"
    }
  },
  {
    "id": "security.inner-html",
    "domain": "chrome-extension",
    "version": 1,
    "category": "security",
    "impact": "medium",
    "confidence": 0.7,
    "appliesTo": [
      "popup",
      "options-page",
      "content-script"
    ],
    "detection": {
      "signals": [
        "innerHTML",
        "outerHTML"
      ],
      "filePatterns": [
        "**/*.js",
        "**/*.ts"
      ],
      "manifestKeys": []
    },
    "summary": "Avoid using innerHTML to prevent XSS",
    "rationale": "Assigning strings to innerHTML can lead to Cross-Site Scripting (XSS) if the data is not sanitized.",
    "recommendation": {
      "action": "Use textContent or standard DOM creation methods",
      "before": "element.innerHTML = userInput;",
      "after": "element.textContent = userInput;"
    }
  },
  {
    "id": "security.web-accessible-resources-restrict",
    "domain": "chrome-extension",
    "version": 1,
    "category": "security",
    "impact": "high",
    "confidence": 0.9,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "web_accessible_resources",
        "\"matches\": [\"<all_urls>\"]"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "web_accessible_resources"
      ]
    },
    "summary": "Restrict web_accessible_resources to specific origins",
    "rationale": "Web accessible resources can be loaded by any website if not restricted, enabling fingerprinting attacks and potential XSS if the resources have vulnerabilities. Always specify exact origin matches and consider using use_dynamic_url for anti-fingerprinting.",
    "recommendation": {
      "action": "Add matches array to restrict which sites can access resources",
      "before": "\"web_accessible_resources\": [{ \"resources\": [\"script.js\"], \"matches\": [\"<all_urls>\"] }]",
      "after": "\"web_accessible_resources\": [{ \"resources\": [\"script.js\"], \"matches\": [\"https://trusted-site.com/*\"], \"use_dynamic_url\": true }]"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/reference/manifest/web-accessible-resources"
    ]
  },
  {
    "id": "security.externally-connectable-restrict",
    "domain": "chrome-extension",
    "version": 1,
    "category": "security",
    "impact": "high",
    "confidence": 0.9,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "externally_connectable",
        "\"matches\": [\"*://*/*\"]"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "externally_connectable"
      ]
    },
    "summary": "Restrict externally_connectable to specific domains",
    "rationale": "The externally_connectable manifest key allows web pages to send messages to your extension. Using broad patterns exposes your extension to attacks from malicious websites. Always specify exact domains that need to communicate with your extension.",
    "recommendation": {
      "action": "Specify exact domains in externally_connectable matches",
      "before": "\"externally_connectable\": { \"matches\": [\"*://*.example.com/*\"] }",
      "after": "\"externally_connectable\": { \"matches\": [\"https://app.example.com/*\"] }"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/develop/concepts/messaging#external-webpage"
    ]
  },
  {
    "id": "security.avoid-eval-patterns",
    "domain": "chrome-extension",
    "version": 1,
    "category": "security",
    "impact": "high",
    "confidence": 1,
    "appliesTo": [
      "service-worker",
      "content-script",
      "popup",
      "options-page"
    ],
    "detection": {
      "signals": [
        "eval(",
        "new Function(",
        "setTimeout(\"",
        "setInterval(\""
      ],
      "filePatterns": [
        "**/*.js",
        "**/*.ts"
      ],
      "manifestKeys": []
    },
    "summary": "Avoid eval and eval-like patterns",
    "rationale": "eval(), new Function(), and setTimeout/setInterval with string arguments execute arbitrary code and are prohibited in MV3. These patterns create security vulnerabilities and will cause CSP violations.",
    "recommendation": {
      "action": "Replace eval patterns with safe alternatives",
      "before": "setTimeout(\"doSomething(\" + id + \")\", 100);",
      "after": "setTimeout(() => doSomething(id), 100);"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/develop/migrate/improve-security"
    ]
  },
  {
    "id": "security.sanitize-content-script-input",
    "domain": "chrome-extension",
    "version": 1,
    "category": "security",
    "impact": "high",
    "confidence": 0.8,
    "appliesTo": [
      "content-script"
    ],
    "detection": {
      "signals": [
        "document.getElementById",
        "document.querySelector",
        "getAttribute"
      ],
      "filePatterns": [
        "content.js",
        "content-script.js",
        "**/*.ts"
      ],
      "manifestKeys": []
    },
    "summary": "Sanitize all data extracted from web pages",
    "rationale": "Content scripts run in the context of potentially malicious web pages. Any data read from the DOM (element text, attributes, etc.) should be treated as untrusted and validated before use, especially before passing to the service worker or using in privileged operations.",
    "recommendation": {
      "action": "Validate and sanitize DOM-extracted data before use",
      "before": "const data = document.getElementById('data').textContent;\nchrome.runtime.sendMessage({ payload: data });",
      "after": "const data = document.getElementById('data')?.textContent || '';\nconst sanitized = data.slice(0, 1000); // Limit size\nif (isValidFormat(sanitized)) { chrome.runtime.sendMessage({ payload: sanitized }); }"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts#security"
    ]
  },
  {
    "id": "architecture.event-driven-sw",
    "domain": "chrome-extension",
    "version": 1,
    "category": "architecture",
    "impact": "high",
    "confidence": 0.9,
    "appliesTo": [
      "service-worker"
    ],
    "detection": {
      "signals": [
        "setInterval",
        "setTimeout"
      ],
      "filePatterns": [
        "background.js",
        "service-worker.js",
        "**/*.ts"
      ],
      "manifestKeys": [
        "background"
      ]
    },
    "summary": "Ensure service worker is event-driven",
    "rationale": "Service workers are ephemeral and terminate after ~30 seconds of inactivity. Individual requests have a 5-minute timeout. Using setTimeout or setInterval for delays beyond these limits will fail when the worker terminates. Use chrome.alarms API for scheduling, and persist state to storage.",
    "recommendation": {
      "action": "Use the chrome.alarms API for scheduling tasks",
      "before": "setInterval(checkUpdates, 60000);",
      "after": "chrome.alarms.create('checkUpdates', { periodInMinutes: 1 }); chrome.alarms.onAlarm.addListener((a) => { if(a.name === 'checkUpdates') checkUpdates(); });"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/develop/concepts/service-workers/lifecycle"
    ]
  },
  {
    "id": "architecture.no-global-state",
    "domain": "chrome-extension",
    "version": 1,
    "category": "architecture",
    "impact": "high",
    "confidence": 0.8,
    "appliesTo": [
      "service-worker"
    ],
    "detection": {
      "signals": [
        "var ",
        "let ",
        "const ",
        "window."
      ],
      "filePatterns": [
        "background.js",
        "**/*context.js"
      ],
      "manifestKeys": []
    },
    "summary": "Avoid relying on global variables in service workers",
    "rationale": "Service workers restart frequently, wiping global variables. Use 'chrome.storage.session' for in-memory persistence during a browser session, or 'chrome.storage.local' for long-term storage.",
    "recommendation": {
      "action": "Persist state to storage",
      "before": "let userCount = 0;",
      "after": "await chrome.storage.session.set({ userCount: 0 });"
    }
  },
  {
    "id": "architecture.mv3-manifest-version",
    "domain": "chrome-extension",
    "version": 1,
    "category": "architecture",
    "impact": "high",
    "confidence": 1,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "\"manifest_version\": 2"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "manifest_version"
      ]
    },
    "summary": "Must use Manifest V3",
    "rationale": "Manifest V2 is deprecated and will be removed. All new extensions must use V3.",
    "recommendation": {
      "action": "Set manifest_version to 3",
      "before": "\"manifest_version\": 2",
      "after": "\"manifest_version\": 3"
    }
  },
  {
    "id": "architecture.separation-of-concerns",
    "domain": "chrome-extension",
    "version": 1,
    "category": "architecture",
    "impact": "medium",
    "confidence": 0.6,
    "appliesTo": [
      "content-script"
    ],
    "detection": {
      "signals": [
        "chrome.runtime.sendMessage",
        "inlined logic"
      ],
      "filePatterns": [
        "content.js"
      ],
      "manifestKeys": []
    },
    "summary": "Separate UI from business logic",
    "rationale": "Content scripts should communicate with the background service worker for heavier logic or cross-origin requests, rather than doing everything in the page context.",
    "recommendation": {
      "action": "Move complex logic to Service Worker and use messaging",
      "before": "// Heavy logic in content script",
      "after": "chrome.runtime.sendMessage({ type: 'PROCESS_DATA', payload: data });"
    }
  },
  {
    "id": "architecture.toplevel-listeners",
    "domain": "chrome-extension",
    "version": 1,
    "category": "architecture",
    "impact": "high",
    "confidence": 0.7,
    "appliesTo": [
      "service-worker"
    ],
    "detection": {
      "signals": [
        "chrome.runtime.onInstalled.addListener",
        "chrome.runtime.onMessage.addListener"
      ],
      "filePatterns": [
        "background.js",
        "service-worker.js",
        "**/*.ts"
      ],
      "manifestKeys": []
    },
    "summary": "Register event listeners synchronously at the top level",
    "rationale": "Service workers are ceased when idle and restarted on events. If listeners are registered asynchronously (e.g., inside other functions or promises), they may not be attached in time to handle the waking event, causing failure.",
    "recommendation": {
      "action": "Move all event listeners to the global scope",
      "before": "async function init() { chrome.runtime.onMessage.addListener(...) }",
      "after": "chrome.runtime.onMessage.addListener(...)"
    }
  },
  {
    "id": "architecture.use-storage-session",
    "domain": "chrome-extension",
    "version": 1,
    "category": "architecture",
    "impact": "medium",
    "confidence": 0.8,
    "appliesTo": [
      "service-worker"
    ],
    "detection": {
      "signals": [
        "chrome.storage.local",
        "let ",
        "var "
      ],
      "filePatterns": [
        "background.js",
        "service-worker.js",
        "**/*.ts"
      ],
      "manifestKeys": []
    },
    "summary": "Use storage.session for service worker state",
    "rationale": "chrome.storage.session provides in-memory storage that persists across service worker restarts within the same browser session. Unlike storage.local, it doesn't persist to disk and is cleared when the browser closes, making it ideal for temporary runtime state.",
    "recommendation": {
      "action": "Use storage.session for transient service worker state",
      "before": "let cachedData = null; // Lost on SW restart",
      "after": "await chrome.storage.session.set({ cachedData: data });\nconst { cachedData } = await chrome.storage.session.get('cachedData');"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/reference/api/storage#property-session"
    ]
  },
  {
    "id": "architecture.on-installed-handler",
    "domain": "chrome-extension",
    "version": 1,
    "category": "architecture",
    "impact": "medium",
    "confidence": 0.9,
    "appliesTo": [
      "service-worker"
    ],
    "detection": {
      "signals": [
        "chrome.runtime.onInstalled"
      ],
      "filePatterns": [
        "background.js",
        "service-worker.js",
        "**/*.ts"
      ],
      "manifestKeys": []
    },
    "summary": "Use onInstalled for one-time initialization",
    "rationale": "The chrome.runtime.onInstalled event fires once on install, update, or Chrome update. Use it for one-time setup like creating context menus, setting default storage values, or opening an onboarding page. Don't put initialization logic that should run on every service worker start.",
    "recommendation": {
      "action": "Set up one-time initialization in onInstalled handler",
      "before": "// Context menu created every time SW starts\nchrome.contextMenus.create({ id: 'myMenu', title: 'My Menu' });",
      "after": "chrome.runtime.onInstalled.addListener(() => {\n  chrome.contextMenus.create({ id: 'myMenu', title: 'My Menu' });\n});"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/reference/api/runtime#event-onInstalled"
    ]
  },
  {
    "id": "architecture.promise-based-apis",
    "domain": "chrome-extension",
    "version": 1,
    "category": "architecture",
    "impact": "low",
    "confidence": 0.8,
    "appliesTo": [
      "service-worker",
      "popup",
      "options-page",
      "content-script"
    ],
    "detection": {
      "signals": [
        "chrome.",
        "function(",
        "callback"
      ],
      "filePatterns": [
        "**/*.js",
        "**/*.ts"
      ],
      "manifestKeys": []
    },
    "summary": "Prefer async/await over callbacks for chrome.* APIs",
    "rationale": "All chrome.* APIs in MV3 support Promises. Using async/await leads to cleaner, more maintainable code and better error handling compared to callback-based patterns.",
    "recommendation": {
      "action": "Use async/await with chrome.* APIs",
      "before": "chrome.storage.local.get(['key'], (result) => { console.log(result.key); });",
      "after": "const { key } = await chrome.storage.local.get(['key']);\nconsole.log(key);"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/develop/migrate/api-calls"
    ]
  },
  {
    "id": "performance.programmatic-injection",
    "domain": "chrome-extension",
    "version": 1,
    "category": "performance",
    "impact": "medium",
    "confidence": 0.8,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "content_scripts"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "content_scripts"
      ]
    },
    "summary": "Prefer programmatic injection for large content scripts",
    "rationale": "Declaring static content scripts injects them into every matching page, consuming memory even if not used. Programmatic injection runs code only when needed.",
    "recommendation": {
      "action": "Use chrome.scripting.executeScript trigger by user action",
      "before": "\"content_scripts\": [{ \"js\": [\"heavy.js\"], \"matches\": [\"<all_urls>\"] }]",
      "after": "// In background.js: chrome.action.onClicked.addListener((tab) => { chrome.scripting.executeScript(...) });"
    }
  },
  {
    "id": "performance.storage-local-vs-sync",
    "domain": "chrome-extension",
    "version": 1,
    "category": "performance",
    "impact": "medium",
    "confidence": 0.7,
    "appliesTo": [
      "service-worker",
      "popup"
    ],
    "detection": {
      "signals": [
        "chrome.storage.sync.set"
      ],
      "filePatterns": [
        "**/*.js",
        "**/*.ts"
      ],
      "manifestKeys": []
    },
    "summary": "Use storage.local for large data",
    "rationale": "chrome.storage.sync has strict quotas (100KB total). Large datasets will cause write failures.",
    "recommendation": {
      "action": "Use chrome.storage.local for non-settings data",
      "before": "chrome.storage.sync.set({ largeCacheData: ... });",
      "after": "chrome.storage.local.set({ largeCacheData: ... });"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/reference/storage/#property-sync"
    ]
  },
  {
    "id": "performance.offscreen-documents",
    "domain": "chrome-extension",
    "version": 1,
    "category": "performance",
    "impact": "high",
    "confidence": 0.9,
    "appliesTo": [
      "service-worker"
    ],
    "detection": {
      "signals": [
        "document.createElement",
        "DOMParser"
      ],
      "filePatterns": [
        "background.js",
        "service-worker.js"
      ],
      "manifestKeys": []
    },
    "summary": "Use offscreen documents for DOM parsing in SW",
    "rationale": "Service workers do not have access to the DOM. usage of window or document will fail. Use the Offscreen API.",
    "recommendation": {
      "action": "Create an offscreen document to parse HTML",
      "before": "const doc = new DOMParser().parseFromString(html, 'text/html');",
      "after": "await chrome.offscreen.createDocument({ ... }); // Send message to offscreen doc to parse"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/reference/offscreen/"
    ]
  },
  {
    "id": "performance.content-script-idle",
    "domain": "chrome-extension",
    "version": 1,
    "category": "performance",
    "impact": "medium",
    "confidence": 0.8,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "document_start",
        "document_end"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "content_scripts"
      ]
    },
    "summary": "Execute content scripts at document_idle",
    "rationale": "Running scripts at 'document_start' blocks the rendering path. 'document_idle' (default) ensures the page is usable before your script runs, improving perceived performance.",
    "recommendation": {
      "action": "Use 'document_idle' unless early injection is critical",
      "before": "\"run_at\": \"document_start\"",
      "after": "\"run_at\": \"document_idle\""
    }
  },
  {
    "id": "ux.options-ui",
    "domain": "chrome-extension",
    "version": 1,
    "category": "ux",
    "impact": "medium",
    "confidence": 0.9,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "options_ui",
        "options_page"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "options_ui"
      ]
    },
    "summary": "Provide an Options Page for configuration",
    "rationale": "Users expect to customize extension behavior via standard Chrome extension management interfaces.",
    "recommendation": {
      "action": "Define 'options_ui' in manifest",
      "before": "// missing options_ui",
      "after": "\"options_ui\": { \"page\": \"options.html\", \"open_in_tab\": false }"
    }
  },
  {
    "id": "ux.action-popup",
    "domain": "chrome-extension",
    "version": 1,
    "category": "ux",
    "impact": "medium",
    "confidence": 0.8,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "action",
        "default_popup"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "action"
      ]
    },
    "summary": "Use a popup for quick interactions",
    "rationale": "Popups provide instant context and control without navigating away from the current page.",
    "recommendation": {
      "action": "Add a default_popup to the action key",
      "before": "\"action\": {}",
      "after": "\"action\": { \"default_popup\": \"popup.html\" }"
    }
  },
  {
    "id": "ux.clean-context-menus",
    "domain": "chrome-extension",
    "version": 1,
    "category": "ux",
    "impact": "low",
    "confidence": 0.7,
    "appliesTo": [
      "service-worker"
    ],
    "detection": {
      "signals": [
        "chrome.contextMenus.create",
        "parentId"
      ],
      "filePatterns": [
        "**/*.js",
        "**/*.ts"
      ],
      "manifestKeys": [
        "permissions"
      ]
    },
    "summary": "Group context menu items",
    "rationale": "Adding multiple top-level context menu items pollutes the browser UI. Group them under a single parent item.",
    "recommendation": {
      "action": "Create a parent menu item and attach children to it",
      "before": "chrome.contextMenus.create({ id: 'item1' }); chrome.contextMenus.create({ id: 'item2' });",
      "after": "chrome.contextMenus.create({ id: 'parent' }); chrome.contextMenus.create({ id: 'item1', parentId: 'parent' });"
    }
  },
  {
    "id": "ux.explicit-user-triggers",
    "domain": "chrome-extension",
    "version": 1,
    "category": "ux",
    "impact": "medium",
    "confidence": 0.6,
    "appliesTo": [
      "content-script"
    ],
    "detection": {
      "signals": [
        "window.onload",
        "document.ready"
      ],
      "filePatterns": [
        "content.js",
        "**/*.js"
      ],
      "manifestKeys": []
    },
    "summary": "Avoid auto-triggering actions on load",
    "rationale": "Extensions should generally wait for user intent (clicks, keypresses) rather than running immediately upon page load, unless that is the primary purpose.",
    "recommendation": {
      "action": "Bind functionality to user events",
      "before": "runMyLogic(); // at top of file",
      "after": "document.addEventListener('click', runMyLogic);"
    }
  },
  {
    "id": "ux.accessibility-tabindex",
    "domain": "chrome-extension",
    "version": 1,
    "category": "ux",
    "impact": "medium",
    "confidence": 0.9,
    "appliesTo": [
      "popup",
      "options-page"
    ],
    "detection": {
      "signals": [
        "tabindex=\"[1-9]\"",
        "tabindex='[1-9]'"
      ],
      "filePatterns": [
        "**/*.html",
        "**/*.js",
        "**/*.ts",
        "**/*.jsx",
        "**/*.tsx"
      ],
      "manifestKeys": []
    },
    "summary": "Avoid positive tabindex values",
    "rationale": "Positive 'tabindex' values disrupt natural tab order, making keyboard navigation confusing. Use '0' (focusable) or '-1' (not focusable) instead.",
    "recommendation": {
      "action": "Remove positive tabindex or set to 0",
      "before": "<button tabindex='1'>Click</button>",
      "after": "<button tabindex='0'>Click</button>"
    }
  },
  {
    "id": "ux.side-panel-ui",
    "domain": "chrome-extension",
    "version": 1,
    "category": "ux",
    "impact": "medium",
    "confidence": 0.8,
    "appliesTo": [
      "manifest",
      "side-panel"
    ],
    "detection": {
      "signals": [
        "side_panel",
        "sidePanel"
      ],
      "filePatterns": [
        "manifest.json",
        "**/*.js",
        "**/*.ts"
      ],
      "manifestKeys": [
        "side_panel"
      ]
    },
    "summary": "Use Side Panel API for persistent companion UIs",
    "rationale": "The Side Panel API (Chrome 114+) provides a persistent UI alongside web content, ideal for tools that users reference while browsing. Unlike popups, side panels remain open across navigation and provide more screen space.",
    "recommendation": {
      "action": "Declare side panel in manifest for companion UI experiences",
      "before": "\"action\": { \"default_popup\": \"panel.html\" } // Closes on click outside",
      "after": "\"side_panel\": { \"default_path\": \"panel.html\" } // Persists while browsing"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/reference/api/sidePanel"
    ]
  },
  {
    "id": "ux.keyboard-shortcuts",
    "domain": "chrome-extension",
    "version": 1,
    "category": "ux",
    "impact": "low",
    "confidence": 0.7,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "commands",
        "_execute_action"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "commands"
      ]
    },
    "summary": "Provide configurable keyboard shortcuts",
    "rationale": "Power users expect keyboard shortcuts for frequently used actions. The commands API allows users to customize shortcuts via chrome://extensions/shortcuts, improving accessibility and efficiency.",
    "recommendation": {
      "action": "Define commands in manifest for key extension actions",
      "before": "// No keyboard shortcuts defined",
      "after": "\"commands\": {\n  \"_execute_action\": {\n    \"suggested_key\": { \"default\": \"Ctrl+Shift+Y\" },\n    \"description\": \"Open extension\"\n  }\n}"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/reference/api/commands"
    ]
  },
  {
    "id": "privacy.minimize-data-collection",
    "domain": "chrome-extension",
    "version": 1,
    "category": "privacy",
    "impact": "high",
    "confidence": 0.6,
    "appliesTo": [
      "content-script",
      "service-worker"
    ],
    "detection": {
      "signals": [
        "google-analytics",
        "mixpanel",
        "tracking"
      ],
      "filePatterns": [
        "**/*.js",
        "**/*.ts"
      ],
      "manifestKeys": []
    },
    "summary": "Minimize data collection",
    "rationale": "Collect only the minimal amount of data necessary. Excessive tracking can lead to store rejection.",
    "recommendation": {
      "action": "Review data collection practices and ensure they are disclosed",
      "before": "ga('send', 'pageview', window.location.href);",
      "after": "// Only track internal interactions, or anonymize URLs"
    }
  },
  {
    "id": "store-compliance.single-purpose",
    "domain": "chrome-extension",
    "version": 1,
    "category": "store-compliance",
    "impact": "high",
    "confidence": 0.5,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "description"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "description"
      ]
    },
    "summary": "Extension must have a single purpose",
    "rationale": "The Chrome Web Store requires extensions to have a single, narrow purpose. Bundling unrelated features violates this policy.",
    "recommendation": {
      "action": "Split unrelated features into separate extensions",
      "before": "// Extension does weather, sports, and stocks",
      "after": "// Extension only does weather"
    },
    "references": [
      "https://developer.chrome.com/docs/webstore/program_policies/single_purpose/"
    ]
  },
  {
    "id": "store-compliance.meaningful-description",
    "domain": "chrome-extension",
    "version": 1,
    "category": "store-compliance",
    "impact": "medium",
    "confidence": 1,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "description"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "description"
      ]
    },
    "summary": "Provide a meaningful description",
    "rationale": "The manifest description must detail what the extension does. 'My Extension' or blank descriptions are grounds for rejection.",
    "recommendation": {
      "action": "Write a descriptive summary (> 10 words)",
      "before": "\"description\": \"My Extension\"",
      "after": "\"description\": \"A productivity tool to organize your tabs by domain and frequency.\""
    }
  },
  {
    "id": "privacy.permissions-justification",
    "domain": "chrome-extension",
    "version": 1,
    "category": "privacy",
    "impact": "high",
    "confidence": 1,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "permissions"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "permissions"
      ]
    },
    "summary": "Justify all permissions",
    "rationale": "You must justify every permission in the privacy tab of the developer dashboard. Unused permissions should be removed.",
    "recommendation": {
      "action": "Remove unused permissions",
      "before": "\"permissions\": [\"tabs\", \"storage\", \"management\"]",
      "after": "\"permissions\": [\"storage\"]"
    }
  },
  {
    "id": "store-compliance.no-obfuscated-code",
    "domain": "chrome-extension",
    "version": 1,
    "category": "store-compliance",
    "impact": "high",
    "confidence": 1,
    "appliesTo": [
      "manifest",
      "service-worker",
      "content-script",
      "popup"
    ],
    "detection": {
      "signals": [
        "eval",
        "atob",
        "String.fromCharCode",
        "_0x"
      ],
      "filePatterns": [
        "**/*.js",
        "**/*.ts"
      ],
      "manifestKeys": []
    },
    "summary": "No obfuscated or minified code that hides functionality",
    "rationale": "The Chrome Web Store prohibits code obfuscation. All code must be human-readable. Minification is allowed if it only removes whitespace/comments, but obfuscation that conceals functionality (like variable mangling or string encoding) will result in rejection.",
    "recommendation": {
      "action": "Use readable code or simple minification without obfuscation",
      "before": "var _0x1a2b=['log'];(function(_0x2d8f){...",
      "after": "console.log('Hello'); // Clear, readable code"
    },
    "references": [
      "https://developer.chrome.com/docs/webstore/program-policies/code-readability/"
    ]
  },
  {
    "id": "store-compliance.privacy-policy-required",
    "domain": "chrome-extension",
    "version": 1,
    "category": "store-compliance",
    "impact": "high",
    "confidence": 1,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "storage",
        "cookies",
        "history",
        "tabs"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "permissions"
      ]
    },
    "summary": "Privacy policy required when collecting user data",
    "rationale": "Extensions that access user data (storage, cookies, browsing history, etc.) must provide a valid privacy policy URL in the Chrome Web Store listing. The policy must describe what data is collected, how it's used, and how it's shared.",
    "recommendation": {
      "action": "Add privacy policy URL to Chrome Web Store listing",
      "before": "// No privacy policy provided",
      "after": "// Add privacy policy URL in Developer Dashboard under 'Privacy' tab"
    },
    "references": [
      "https://developer.chrome.com/docs/webstore/program-policies/user-data-faq/"
    ]
  },
  {
    "id": "store-compliance.accurate-listing",
    "domain": "chrome-extension",
    "version": 1,
    "category": "store-compliance",
    "impact": "high",
    "confidence": 0.7,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "name",
        "description"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "name",
        "description"
      ]
    },
    "summary": "Extension behavior must match store listing",
    "rationale": "As of 2024, all elements in your product listing (description, screenshots, videos) must accurately represent the extension's functionality. Extensions that behave differently than described face removal from the Chrome Web Store.",
    "recommendation": {
      "action": "Ensure manifest description and store listing accurately describe all functionality",
      "before": "\"description\": \"Simple tab manager\" // but actually injects ads",
      "after": "\"description\": \"Tab manager with sponsored suggestions\" // accurately describes behavior"
    },
    "references": [
      "https://developer.chrome.com/docs/webstore/program-policies/listing-requirements/"
    ]
  },
  {
    "id": "networking.declarative-net-request",
    "domain": "chrome-extension",
    "version": 1,
    "category": "networking",
    "impact": "high",
    "confidence": 0.9,
    "appliesTo": [
      "manifest",
      "service-worker"
    ],
    "detection": {
      "signals": [
        "webRequest",
        "webRequestBlocking",
        "chrome.webRequest"
      ],
      "filePatterns": [
        "manifest.json",
        "**/*.js",
        "**/*.ts"
      ],
      "manifestKeys": [
        "permissions"
      ]
    },
    "summary": "Prefer declarativeNetRequest over webRequest for blocking",
    "rationale": "The declarativeNetRequest API is the MV3 replacement for blocking webRequest. It offers better performance (browser-native rule evaluation), improved privacy (no access to request content), and doesn't require broad host permissions for basic blocking.",
    "recommendation": {
      "action": "Migrate from webRequest to declarativeNetRequest API",
      "before": "chrome.webRequest.onBeforeRequest.addListener((details) => { return { cancel: true }; }, { urls: ['*://*.ads.com/*'] }, ['blocking']);",
      "after": "// Use declarative_net_request in manifest with rule files\n// manifest.json: \"declarative_net_request\": { \"rule_resources\": [{ \"id\": \"ruleset_1\", \"enabled\": true, \"path\": \"rules.json\" }] }"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/reference/api/declarativeNetRequest"
    ]
  },
  {
    "id": "networking.static-rulesets-for-blocklists",
    "domain": "chrome-extension",
    "version": 1,
    "category": "networking",
    "impact": "medium",
    "confidence": 0.8,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "declarative_net_request",
        "updateDynamicRules"
      ],
      "filePatterns": [
        "manifest.json",
        "**/*.js",
        "**/*.ts"
      ],
      "manifestKeys": [
        "declarative_net_request"
      ]
    },
    "summary": "Use static rulesets for large, stable blocklists",
    "rationale": "Static rules (bundled in extension package) have higher limits (up to 330,000 rules across all extensions) compared to dynamic rules (5,000-30,000). Use static rules for core blocking logic that rarely changes, and dynamic rules only for user-configurable or frequently updated filters.",
    "recommendation": {
      "action": "Define large blocklists as static rulesets in manifest",
      "before": "chrome.declarativeNetRequest.updateDynamicRules({ addRules: thousandsOfRules });",
      "after": "// manifest.json: \"declarative_net_request\": { \"rule_resources\": [{ \"id\": \"blocklist\", \"enabled\": true, \"path\": \"blocklist_rules.json\" }] }"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/reference/api/declarativeNetRequest#limits"
    ]
  },
  {
    "id": "networking.cors-service-worker",
    "domain": "chrome-extension",
    "version": 1,
    "category": "networking",
    "impact": "medium",
    "confidence": 0.7,
    "appliesTo": [
      "service-worker"
    ],
    "detection": {
      "signals": [
        "fetch(",
        "XMLHttpRequest",
        "mode: 'no-cors'"
      ],
      "filePatterns": [
        "background.js",
        "service-worker.js",
        "**/*.ts"
      ],
      "manifestKeys": [
        "host_permissions"
      ]
    },
    "summary": "Handle CORS properly in service worker fetch requests",
    "rationale": "Service workers can make cross-origin requests if host_permissions are declared, but the response mode and headers must be handled correctly. Using 'no-cors' mode returns an opaque response that cannot be read.",
    "recommendation": {
      "action": "Declare proper host_permissions and use standard fetch mode",
      "before": "fetch('https://api.example.com/data', { mode: 'no-cors' })",
      "after": "// Add \"host_permissions\": [\"https://api.example.com/*\"] to manifest\nfetch('https://api.example.com/data') // CORS works with host_permissions"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/develop/concepts/network-requests"
    ]
  }
]
[
  {
    "id": "permissions.no-all-urls",
    "domain": "chrome-extension",
    "version": 1,
    "category": "permissions",
    "impact": "high",
    "confidence": 1,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "<all_urls>"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "permissions",
        "host_permissions"
      ]
    },
    "summary": "Avoid requesting <all_urls> permission",
    "rationale": "Requesting access to all URLs triggers a separate, more rigorous review process and alarms users during installation. It violates the principle of least privilege.",
    "recommendation": {
      "action": "Limit host permissions to specific domains",
      "before": "\"host_permissions\": [\"<all_urls>\"]",
      "after": "\"host_permissions\": [\"https://*.example.com/*\"]"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/mv3/permission_warnings/"
    ]
  },
  {
    "id": "permissions.minimize-host-permissions",
    "domain": "chrome-extension",
    "version": 1,
    "category": "permissions",
    "impact": "high",
    "confidence": 0.9,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "*://*/*",
        "http://*/*",
        "https://*/*"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "host_permissions"
      ]
    },
    "summary": "Avoid wildcard host permissions",
    "rationale": "Broad wildcard permissions (*://*/*) grant access to every site, presenting a high security risk and reducing user trust.",
    "recommendation": {
      "action": "Specify exact domains required for functionality",
      "before": "\"host_permissions\": [\"*://*/*\"]",
      "after": "\"host_permissions\": [\"https://api.myservice.com/*\"]"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/mv3/declare_permissions/"
    ]
  },
  {
    "id": "permissions.active-tab",
    "domain": "chrome-extension",
    "version": 1,
    "category": "permissions",
    "impact": "medium",
    "confidence": 0.8,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "tabs"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "permissions"
      ]
    },
    "summary": "Prefer activeTab over broad tabs or host permissions",
    "rationale": "The activeTab permission grants temporary access to the current tab only when the user invokes the extension, avoiding the need for permanent host permissions.",
    "recommendation": {
      "action": "Replace 'tabs' or host permissions with 'activeTab' where interactive access is sufficient",
      "before": "\"permissions\": [\"tabs\"]",
      "after": "\"permissions\": [\"activeTab\"]"
    }
  },
  {
    "id": "permissions.clipboard-access",
    "domain": "chrome-extension",
    "version": 1,
    "category": "permissions",
    "impact": "medium",
    "confidence": 1,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "clipboardRead",
        "clipboardWrite"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "permissions"
      ]
    },
    "summary": "Use clipboard permissions only when necessary",
    "rationale": "Clipboard access is sensitive. Ensure it is absolutely required for the core feature set.",
    "recommendation": {
      "action": "Remove clipboard permissions if not critical, or use the standard Clipboard API with user gesture",
      "before": "\"permissions\": [\"clipboardRead\"]",
      "after": "// Use navigator.clipboard.readText() inside a user-triggered event handler"
    }
  },
  {
    "id": "security.no-remote-code",
    "domain": "chrome-extension",
    "version": 1,
    "category": "security",
    "impact": "high",
    "confidence": 1,
    "appliesTo": [
      "manifest",
      "content-script",
      "service-worker"
    ],
    "detection": {
      "signals": [
        "eval",
        "new Function",
        "generated-script"
      ],
      "filePatterns": [
        "**/*.js",
        "**/*.ts",
        "manifest.json"
      ],
      "manifestKeys": [
        "content_security_policy"
      ]
    },
    "summary": "Remote code execution is prohibited",
    "rationale": "Manifest V3 strictly forbids remotely hosted code (including via eval or handling scripts from external servers).",
    "recommendation": {
      "action": "Bundle all necessary libraries inside the extension package",
      "before": "script.src = 'https://cdn.example.com/lib.js';",
      "after": "import { lib } from './local-lib.js';"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/mv3/intro/mv3-migration/#remotely-hosted-code"
    ]
  },
  {
    "id": "security.strict-csp",
    "domain": "chrome-extension",
    "version": 1,
    "category": "security",
    "impact": "high",
    "confidence": 1,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "unsafe-eval",
        "unsafe-inline",
        "https:",
        "http:"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "content_security_policy"
      ]
    },
    "summary": "Enforce strict Content Security Policy (CSP)",
    "rationale": "Manifest V3 requires 'script-src' and 'object-src' to be 'self' or 'none'. 'unsafe-eval' is only permitted in sandboxed pages, and remote sources are banned.",
    "recommendation": {
      "action": "Remove remote domains and unsafe policies from CSP",
      "before": "\"content_security_policy\": { \"extension_pages\": \"script-src 'self' https://example.com; object-src 'self'\" }",
      "after": "\"content_security_policy\": { \"extension_pages\": \"script-src 'self'; object-src 'self'\" }"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/mv3/manifest/content_security_policy/"
    ]
  },
  {
    "id": "security.content-script-isolation",
    "domain": "chrome-extension",
    "version": 1,
    "category": "security",
    "impact": "high",
    "confidence": 0.9,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "\"world\": \"MAIN\""
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "content_scripts"
      ]
    },
    "summary": "Avoid running content scripts in the MAIN world",
    "rationale": "Scripts in the MAIN world share the host page's execution environment, allowing the page to interfere with them or steal data. Use the default ISOLATED world for security.",
    "recommendation": {
      "action": "Remove 'world': 'MAIN' or switch to 'ISOLATED'",
      "before": "\"content_scripts\": [{ \"world\": \"MAIN\", ... }]",
      "after": "\"content_scripts\": [{ \"world\": \"ISOLATED\", ... }]"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/mv3/content_scripts/#isolated_world"
    ]
  },
  {
    "id": "security.safe-message-passing",
    "domain": "chrome-extension",
    "version": 1,
    "category": "security",
    "impact": "high",
    "confidence": 0.8,
    "appliesTo": [
      "service-worker",
      "content-script"
    ],
    "detection": {
      "signals": [
        "runtime.onMessage.addListener",
        "sender.tab",
        "sender.id"
      ],
      "filePatterns": [
        "**/*.js",
        "**/*.ts"
      ],
      "manifestKeys": []
    },
    "summary": "Validate sender in all message listeners",
    "rationale": "Message listeners can receive messages from other extensions or websites if 'externally_connectable' is defined. Even without it, validating 'sender.id' ensures you are only processing trusted checks.",
    "recommendation": {
      "action": "Check sender.id equals chrome.runtime.id in listeners",
      "before": "chrome.runtime.onMessage.addListener((msg) => { doWork(msg); });",
      "after": "chrome.runtime.onMessage.addListener((msg, sender) => { if (sender.id !== chrome.runtime.id) return; doWork(msg); });"
    }
  },
  {
    "id": "security.https-only",
    "domain": "chrome-extension",
    "version": 1,
    "category": "security",
    "impact": "high",
    "confidence": 1,
    "appliesTo": [
      "service-worker",
      "content-script"
    ],
    "detection": {
      "signals": [
        "http://"
      ],
      "filePatterns": [
        "**/*.js",
        "**/*.ts"
      ],
      "manifestKeys": []
    },
    "summary": "Use HTTPS for all network requests",
    "rationale": "Unencrypted HTTP requests are vulnerable to MITM attacks. Chrome extensions should only communicate over secure channels.",
    "recommendation": {
      "action": "Change all API endpoints to https://",
      "before": "fetch('http://api.example.com/data')",
      "after": "fetch('https://api.example.com/data')"
    }
  },
  {
    "id": "security.inner-html",
    "domain": "chrome-extension",
    "version": 1,
    "category": "security",
    "impact": "medium",
    "confidence": 0.7,
    "appliesTo": [
      "popup",
      "options-page",
      "content-script"
    ],
    "detection": {
      "signals": [
        "innerHTML",
        "outerHTML"
      ],
      "filePatterns": [
        "**/*.js",
        "**/*.ts"
      ],
      "manifestKeys": []
    },
    "summary": "Avoid using innerHTML to prevent XSS",
    "rationale": "Assigning strings to innerHTML can lead to Cross-Site Scripting (XSS) if the data is not sanitized.",
    "recommendation": {
      "action": "Use textContent or standard DOM creation methods",
      "before": "element.innerHTML = userInput;",
      "after": "element.textContent = userInput;"
    }
  },
  {
    "id": "architecture.event-driven-sw",
    "domain": "chrome-extension",
    "version": 1,
    "category": "architecture",
    "impact": "high",
    "confidence": 0.9,
    "appliesTo": [
      "service-worker"
    ],
    "detection": {
      "signals": [
        "setInterval",
        "setTimeout"
      ],
      "filePatterns": [
        "background.js",
        "service-worker.js",
        "**/*.ts"
      ],
      "manifestKeys": [
        "background"
      ]
    },
    "summary": "Ensure service worker is event-driven",
    "rationale": "Service workers are ephemeral and terminate when idle (typically after 30 seconds). Using setTimeout or setInterval for longer delays will fail when the worker sleeps.",
    "recommendation": {
      "action": "Use the chrome.alarms API for scheduling tasks",
      "before": "setInterval(checkUpdates, 60000);",
      "after": "chrome.alarms.create('checkUpdates', { periodInMinutes: 1 }); chrome.alarms.onAlarm.addListener((a) => { if(a.name === 'checkUpdates') checkUpdates(); });"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/mv3/service_workers/"
    ]
  },
  {
    "id": "architecture.no-global-state",
    "domain": "chrome-extension",
    "version": 1,
    "category": "architecture",
    "impact": "high",
    "confidence": 0.8,
    "appliesTo": [
      "service-worker"
    ],
    "detection": {
      "signals": [
        "var ",
        "let ",
        "const ",
        "window."
      ],
      "filePatterns": [
        "background.js",
        "**/*context.js"
      ],
      "manifestKeys": []
    },
    "summary": "Avoid relying on global variables in service workers",
    "rationale": "Service workers restart frequently, wiping global variables. Use 'chrome.storage.session' for in-memory persistence during a browser session, or 'chrome.storage.local' for long-term storage.",
    "recommendation": {
      "action": "Persist state to storage",
      "before": "let userCount = 0;",
      "after": "await chrome.storage.session.set({ userCount: 0 });"
    }
  },
  {
    "id": "architecture.mv3-manifest-version",
    "domain": "chrome-extension",
    "version": 1,
    "category": "architecture",
    "impact": "high",
    "confidence": 1,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "\"manifest_version\": 2"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "manifest_version"
      ]
    },
    "summary": "Must use Manifest V3",
    "rationale": "Manifest V2 is deprecated and will be removed. All new extensions must use V3.",
    "recommendation": {
      "action": "Set manifest_version to 3",
      "before": "\"manifest_version\": 2",
      "after": "\"manifest_version\": 3"
    }
  },
  {
    "id": "architecture.separation-of-concerns",
    "domain": "chrome-extension",
    "version": 1,
    "category": "architecture",
    "impact": "medium",
    "confidence": 0.6,
    "appliesTo": [
      "content-script"
    ],
    "detection": {
      "signals": [
        "chrome.runtime.sendMessage",
        "inlined logic"
      ],
      "filePatterns": [
        "content.js"
      ],
      "manifestKeys": []
    },
    "summary": "Separate UI from business logic",
    "rationale": "Content scripts should communicate with the background service worker for heavier logic or cross-origin requests, rather than doing everything in the page context.",
    "recommendation": {
      "action": "Move complex logic to Service Worker and use messaging",
      "before": "// Heavy logic in content script",
      "after": "chrome.runtime.sendMessage({ type: 'PROCESS_DATA', payload: data });"
    }
  },
  {
    "id": "architecture.toplevel-listeners",
    "domain": "chrome-extension",
    "version": 1,
    "category": "architecture",
    "impact": "high",
    "confidence": 0.7,
    "appliesTo": [
      "service-worker"
    ],
    "detection": {
      "signals": [
        "chrome.runtime.onInstalled.addListener",
        "chrome.runtime.onMessage.addListener"
      ],
      "filePatterns": [
        "background.js",
        "service-worker.js",
        "**/*.ts"
      ],
      "manifestKeys": []
    },
    "summary": "Register event listeners synchronously at the top level",
    "rationale": "Service workers are ceased when idle and restarted on events. If listeners are registered asynchronously (e.g., inside other functions or promises), they may not be attached in time to handle the waking event, causing failure.",
    "recommendation": {
      "action": "Move all event listeners to the global scope",
      "before": "async function init() { chrome.runtime.onMessage.addListener(...) }",
      "after": "chrome.runtime.onMessage.addListener(...)"
    }
  },
  {
    "id": "performance.programmatic-injection",
    "domain": "chrome-extension",
    "version": 1,
    "category": "performance",
    "impact": "medium",
    "confidence": 0.8,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "content_scripts"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "content_scripts"
      ]
    },
    "summary": "Prefer programmatic injection for large content scripts",
    "rationale": "Declaring static content scripts injects them into every matching page, consuming memory even if not used. Programmatic injection runs code only when needed.",
    "recommendation": {
      "action": "Use chrome.scripting.executeScript trigger by user action",
      "before": "\"content_scripts\": [{ \"js\": [\"heavy.js\"], \"matches\": [\"<all_urls>\"] }]",
      "after": "// In background.js: chrome.action.onClicked.addListener((tab) => { chrome.scripting.executeScript(...) });"
    }
  },
  {
    "id": "performance.storage-local-vs-sync",
    "domain": "chrome-extension",
    "version": 1,
    "category": "performance",
    "impact": "medium",
    "confidence": 0.7,
    "appliesTo": [
      "service-worker",
      "popup"
    ],
    "detection": {
      "signals": [
        "chrome.storage.sync.set"
      ],
      "filePatterns": [
        "**/*.js",
        "**/*.ts"
      ],
      "manifestKeys": []
    },
    "summary": "Use storage.local for large data",
    "rationale": "chrome.storage.sync has strict quotas (100KB total). Large datasets will cause write failures.",
    "recommendation": {
      "action": "Use chrome.storage.local for non-settings data",
      "before": "chrome.storage.sync.set({ largeCacheData: ... });",
      "after": "chrome.storage.local.set({ largeCacheData: ... });"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/reference/storage/#property-sync"
    ]
  },
  {
    "id": "performance.offscreen-documents",
    "domain": "chrome-extension",
    "version": 1,
    "category": "performance",
    "impact": "high",
    "confidence": 0.9,
    "appliesTo": [
      "service-worker"
    ],
    "detection": {
      "signals": [
        "document.createElement",
        "DOMParser"
      ],
      "filePatterns": [
        "background.js",
        "service-worker.js"
      ],
      "manifestKeys": []
    },
    "summary": "Use offscreen documents for DOM parsing in SW",
    "rationale": "Service workers do not have access to the DOM. usage of window or document will fail. Use the Offscreen API.",
    "recommendation": {
      "action": "Create an offscreen document to parse HTML",
      "before": "const doc = new DOMParser().parseFromString(html, 'text/html');",
      "after": "await chrome.offscreen.createDocument({ ... }); // Send message to offscreen doc to parse"
    },
    "references": [
      "https://developer.chrome.com/docs/extensions/reference/offscreen/"
    ]
  },
  {
    "id": "performance.content-script-idle",
    "domain": "chrome-extension",
    "version": 1,
    "category": "performance",
    "impact": "medium",
    "confidence": 0.8,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "document_start",
        "document_end"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "content_scripts"
      ]
    },
    "summary": "Execute content scripts at document_idle",
    "rationale": "Running scripts at 'document_start' blocks the rendering path. 'document_idle' (default) ensures the page is usable before your script runs, improving perceived performance.",
    "recommendation": {
      "action": "Use 'document_idle' unless early injection is critical",
      "before": "\"run_at\": \"document_start\"",
      "after": "\"run_at\": \"document_idle\""
    }
  },
  {
    "id": "ux.options-ui",
    "domain": "chrome-extension",
    "version": 1,
    "category": "ux",
    "impact": "medium",
    "confidence": 0.9,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "options_ui",
        "options_page"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "options_ui"
      ]
    },
    "summary": "Provide an Options Page for configuration",
    "rationale": "Users expect to customize extension behavior via standard Chrome extension management interfaces.",
    "recommendation": {
      "action": "Define 'options_ui' in manifest",
      "before": "// missing options_ui",
      "after": "\"options_ui\": { \"page\": \"options.html\", \"open_in_tab\": false }"
    }
  },
  {
    "id": "ux.action-popup",
    "domain": "chrome-extension",
    "version": 1,
    "category": "ux",
    "impact": "medium",
    "confidence": 0.8,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "action",
        "default_popup"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "action"
      ]
    },
    "summary": "Use a popup for quick interactions",
    "rationale": "Popups provide instant context and control without navigating away from the current page.",
    "recommendation": {
      "action": "Add a default_popup to the action key",
      "before": "\"action\": {}",
      "after": "\"action\": { \"default_popup\": \"popup.html\" }"
    }
  },
  {
    "id": "ux.clean-context-menus",
    "domain": "chrome-extension",
    "version": 1,
    "category": "ux",
    "impact": "low",
    "confidence": 0.7,
    "appliesTo": [
      "service-worker"
    ],
    "detection": {
      "signals": [
        "chrome.contextMenus.create",
        "parentId"
      ],
      "filePatterns": [
        "**/*.js",
        "**/*.ts"
      ],
      "manifestKeys": [
        "permissions"
      ]
    },
    "summary": "Group context menu items",
    "rationale": "Adding multiple top-level context menu items pollutes the browser UI. Group them under a single parent item.",
    "recommendation": {
      "action": "Create a parent menu item and attach children to it",
      "before": "chrome.contextMenus.create({ id: 'item1' }); chrome.contextMenus.create({ id: 'item2' });",
      "after": "chrome.contextMenus.create({ id: 'parent' }); chrome.contextMenus.create({ id: 'item1', parentId: 'parent' });"
    }
  },
  {
    "id": "ux.explicit-user-triggers",
    "domain": "chrome-extension",
    "version": 1,
    "category": "ux",
    "impact": "medium",
    "confidence": 0.6,
    "appliesTo": [
      "content-script"
    ],
    "detection": {
      "signals": [
        "window.onload",
        "document.ready"
      ],
      "filePatterns": [
        "content.js",
        "**/*.js"
      ],
      "manifestKeys": []
    },
    "summary": "Avoid auto-triggering actions on load",
    "rationale": "Extensions should generally wait for user intent (clicks, keypresses) rather than running immediately upon page load, unless that is the primary purpose.",
    "recommendation": {
      "action": "Bind functionality to user events",
      "before": "runMyLogic(); // at top of file",
      "after": "document.addEventListener('click', runMyLogic);"
    }
  },
  {
    "id": "ux.accessibility-tabindex",
    "domain": "chrome-extension",
    "version": 1,
    "category": "ux",
    "impact": "medium",
    "confidence": 0.9,
    "appliesTo": [
      "popup",
      "options-page"
    ],
    "detection": {
      "signals": [
        "tabindex=\"[1-9]\"",
        "tabindex='[1-9]'"
      ],
      "filePatterns": [
        "**/*.html",
        "**/*.js",
        "**/*.ts",
        "**/*.jsx",
        "**/*.tsx"
      ],
      "manifestKeys": []
    },
    "summary": "Avoid positive tabindex values",
    "rationale": "Positive 'tabindex' values disrupt natural tab order, making keyboard navigation confusing. Use '0' (focusable) or '-1' (not focusable) instead.",
    "recommendation": {
      "action": "Remove positive tabindex or set to 0",
      "before": "<button tabindex='1'>Click</button>",
      "after": "<button tabindex='0'>Click</button>"
    }
  },
  {
    "id": "privacy.minimize-data-collection",
    "domain": "chrome-extension",
    "version": 1,
    "category": "privacy",
    "impact": "high",
    "confidence": 0.6,
    "appliesTo": [
      "content-script",
      "service-worker"
    ],
    "detection": {
      "signals": [
        "google-analytics",
        "mixpanel",
        "tracking"
      ],
      "filePatterns": [
        "**/*.js",
        "**/*.ts"
      ],
      "manifestKeys": []
    },
    "summary": "Minimize data collection",
    "rationale": "Collect only the minimal amount of data necessary. Excessive tracking can lead to store rejection.",
    "recommendation": {
      "action": "Review data collection practices and ensure they are disclosed",
      "before": "ga('send', 'pageview', window.location.href);",
      "after": "// Only track internal interactions, or anonymize URLs"
    }
  },
  {
    "id": "store-compliance.single-purpose",
    "domain": "chrome-extension",
    "version": 1,
    "category": "store-compliance",
    "impact": "high",
    "confidence": 0.5,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "description"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "description"
      ]
    },
    "summary": "Extension must have a single purpose",
    "rationale": "The Chrome Web Store requires extensions to have a single, narrow purpose. Bundling unrelated features violates this policy.",
    "recommendation": {
      "action": "Split unrelated features into separate extensions",
      "before": "// Extension does weather, sports, and stocks",
      "after": "// Extension only does weather"
    },
    "references": [
      "https://developer.chrome.com/docs/webstore/program_policies/single_purpose/"
    ]
  },
  {
    "id": "store-compliance.meaningful-description",
    "domain": "chrome-extension",
    "version": 1,
    "category": "store-compliance",
    "impact": "medium",
    "confidence": 1,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "description"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "description"
      ]
    },
    "summary": "Provide a meaningful description",
    "rationale": "The manifest description must detail what the extension does. 'My Extension' or blank descriptions are grounds for rejection.",
    "recommendation": {
      "action": "Write a descriptive summary (> 10 words)",
      "before": "\"description\": \"My Extension\"",
      "after": "\"description\": \"A productivity tool to organize your tabs by domain and frequency.\""
    }
  },
  {
    "id": "privacy.permissions-justification",
    "domain": "chrome-extension",
    "version": 1,
    "category": "privacy",
    "impact": "high",
    "confidence": 1,
    "appliesTo": [
      "manifest"
    ],
    "detection": {
      "signals": [
        "permissions"
      ],
      "filePatterns": [
        "manifest.json"
      ],
      "manifestKeys": [
        "permissions"
      ]
    },
    "summary": "Justify all permissions",
    "rationale": "You must justify every permission in the privacy tab of the developer dashboard. Unused permissions should be removed.",
    "recommendation": {
      "action": "Remove unused permissions",
      "before": "\"permissions\": [\"tabs\", \"storage\", \"management\"]",
      "after": "\"permissions\": [\"storage\"]"
    }
  }
]